# 유클리드 호제법 (Euclidean-algorithm)

## 서론 🤨

### GCD?

Greatest Common Divisor, 즉 최대 공약수.

### LCM?

Least Common Multiple 또는 Lowest Common Multiple, 즉 최소 공배수.

<br/>

알고리즘 문제를 풀다보면 최대공약수 또는 최소공배수를 구하는 문제를 마주칠 때가 있다. 그 때마다 ✨유클리드 호제법✨을 사용해서 문제를 풀게되는데 매번 까먹게되더라 😅

이 참에 확실하게 정리해보자!

## 본론 🧐

### 유클리드 호제법?

2개의 자연수의 최대공약수를 구하는 알고리즘 중 하나이다.

> **호제법?**
> 호제법이란 말은 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘!

2개의 자연수 `A`, `B`에 대해서(이 때, `A > B`) `A = q * B + R`이라 하면, `A`와 `B`의 최대공약수는 `B`와 `R`의 최대공약수와 같다. 이 성질에 따라 과정을 반복하여 나머지가 `0`이 되었을 때 나누는 수(`B'`)가 `A`와 `B`의 최대공약수라는 이론.

### 간단한 증명

`GCD(A, B) = GCD(B, R)` 라는 이론이 어떻게 가능한건지 아주 아주 간단하게 증명을 통해 알아보자 🤔

#### 0️⃣ 최대 공약수를 G라고 하면

- **A = Ga**, **B = Gb** 라고 볼 수 있고, 이 때 <span style='background-color: #fff5b1'>**a와 b는 서로소**</span>이다.

> 💡 조금만 생각해보면 아주 당연한 이야기.
> `a`와 `b`가 공약수를 가진다면 `G`가 최대공약수라고 할 수 없기 때문!

#### 1️⃣ A = Bq + R을 새롭게 꾸며보자

- 0️⃣에서 구한 **A = Ga**, **B = Gb**를 가지고 위 식에 대입해주자.
- **Ga = Gbq + R**
- `R`을 기준으로 이항해주면 **R = Ga - Gbq**가 되고 이 식을 정리해보자면, <span style="background-color:#fff5b1">**R = G(a-bq)**</span>가 된다

#### 2️⃣ 만약 b와 a-bq가 서로소라면 증명 완료!

- 0️⃣에서 구한 **B = Gb**, 1️⃣에서 구한 **R = G(a-bq)** 여기서 `b`와 `a-bq`가 서로소라면 `G`가 `B`와 `R`의 최대공약수이다.
- 즉 **<span style="background-color:#fff5b1">GCD(A, B) == GCD(B, R)</span>** 가 성립된다는 말!

#### 3️⃣ b와 a-bq가 서로소인지 알아보자

> 💡 가정의 모순을 확인하는 귀류법을 이용해서 알아보자.
> 둘 사이의 공약수 `k`를 가진다고 가정하고, 이 것이 참이라면 2️⃣의 명제는 거짓이, 반대로 거짓이라면 2️⃣의 명제는 참이 된다.

<span style="color:#bbb">여기서 조금 복잡하게 느껴질 수 있지만 찬찬히 생각해보면 모두 당연한 이야기라는 것을 알 수 있다.</span>

- **a-bq = km**, **b = kn** 라고 생각을 해보자. ( 0️⃣에서 했던 것과 같은 방식 )
- 위 식 **a-bq = km**를 `a`를 기준으로 이항해 정리해보자.
- **a = km + bq**가 되고 여기에 `b = kn`을 이용해 `b`값을 대입해주자.
- **a = km + knq**가 되고 `k`로 묶어 정리해주면 **<span style="background-color:#fff5b1">a = k(m - nq)</span>**

여기에서 모순이 발생해버린다. 우리는 이미 0️⃣에서 `a`와 `b`는 서로소를 전제로 했는데 **<span style="background-color:#fff5b1">a = k(m - nq), b = kn 공통으로 k라는 공약수를 가지게 되어버린다.</span>**

따라서 `b`와 `a-bq` 사이의 `k`라는 공약수를 가진다는 가정은 거짓이고, 2️⃣의 명제는 **참**이된다!

#### 4️⃣ 증명 끝!

따라서 **GCD(A, B) = GCD(B, R)** 는 참이되고, 이 과정을 반복하다가 나머지의 수, 즉 `R'`의 값이 `0`이 되는 순간의 나누는 수 `B'`의 값이 **최대 공약수**가 된다

### 사용법

유클리드 호제법을 이용해서 최대공약수를 구하는 파이썬 코드

```python
# 큰 값을 A로 작은 값을 B로 입력받기
B, A = sorted(map(int, input().split()))
    # 유킬리드 호제법!
    while True :
        R = A % B
        if R == 0 :
            return B # 최대공약수 반환
        A, B = B, R
```

우리는 이제 최대공약수를 구할 수 있으니 최소공배수도 쉽게 구할 수 있을 것이다.

> 💡 두 수의 최대공배수는, 두 수의 최소공배수를 최대공약수로 나눈 몫과 같다.

유클리드 호제법을 이용해서 최소공배수를 구하는 파이썬 코드

```python
# 큰 값을 A로 작은 값을 B로 입력받기
B, A = sorted(map(int, input().split()))
	M = A * B
    # 유킬리드 호제법!
    while True :
        R = A % B
        if R == 0 :
            return M // B # 최소공배수 반환
        A, B = B, R
```

## 정리 🤓

유클리드 호제법을 이용하면 최대공배수를 비교적 적은 연산 횟수로 구할 수 있다.
이를 이용한다면 최소공배수도 쉽게 구할 수 있을 것!

### 내 맘대로 정의하는 유클리드 호제법

    ✊ 큰 수를 작은 수로 나눈다.
    👍 나누는 수가 큰 수, 나머지가 작은 수가 된다.
    🤘 위 과정을 반복한다.
    🤟 0이 나오는 순간의 작은 수가 최대공약수
